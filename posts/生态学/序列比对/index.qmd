---
title: "序列比对"
title-block-banner: false
author: "舒子豪"
date: 2022-2-28
categories: [生物信息学]
image: seq17.png
about: 
    template: marquee
---

# 替换记分矩阵
## 核酸序列的替换记分矩阵
替换记分矩阵是反映残基之间相互替换率的矩阵。也就是说，它描述了残基两两相似的量化关系。
DNA序列的替换记分矩阵主要有三种。

1. 等价矩阵

其中，相同核苷酸之间的匹配得分为1，不同核苷酸闾的替换得分为0。由于不含有碱基的理化信息和不区别对待不同的替换，在实际的序列比较中很少使用，一般只用于理论计算。

2. 转换-颠换矩阵

我们说核酸的碱基按照环结构特征被划分为两类，一类是嘌呤，包括腺嘌呤A和鸟嘌呤G，它们都有两个环；另一类是嘧啶，包括胞嘧啶C和胸腺嘧啶T，它们只有一个环。如果DNA碱基的替换保持环数不变，则称为转换，比如腺嘌呤A替换为鸟嘌呤G、或者胞咤啶C替换为胸腺嘧啶T，也就是嘌呤变嘌呤，嚰啶变嘧啶；如果环数发生变化，则称为颠换，比如腺嘌呤A替换为胞嘧啶C、或者胸腺嘧啶T替换为鸟嘌呤G，也就是嘌呤变嘧啶，或者嘧啶变嘌呤。在进化过程中，转换发生的频率远比颠换高。也就是说，大自然更倾向于接受嘌呤和嘌呤之间的替换，以及嘧啶和嘧啶之间的替换，而嘌呤和嘧啶之间的替换会导致不好的事情发生，这种替换大多在进化过程中已经被淘汰了。为了反映这一情况，转换-颠换矩阵中，转换的得分比颠换要高为-1分，而颠换的得分为-5分。

3. BLAST矩阵

经过大量实际比对发现，如果令被比对的两个核苷酸相同时得分为+5分，不相同为-4分，这时比对效果最好。这个矩阵广泛地被DNA序列比较所采用。没有为什么，就是好，实践经验所得。因为这个矩阵最早应用于BLAST'工具，因此得名BLAST矩阵。有关BLAST的内容将在后面的章节详细介绍。DNA序列常见的三种替换记分矩阵就是这三个。

<center>![DNA序列的三种替换记分矩阵](DNA序列的三种替换记分矩阵.png)</center>

## 蛋白质的替换记分矩阵
蛋白质最常用的两种矩阵是PAM矩阵和BLOSUM矩阵。

### PAM矩阵
PAM 矩阵是目前蛋白质序列比较中最广泛使用的记分方法之一。基础的PAM-1矩阵反应的是进化产生的每一百个氨基酸平均发生一个突变的量值，由统计方法得到。PAM-1自乘n次，可以得到PAM-n，表示发生了更多次突变。我们需要根据要比较的序列之间的亲缘关系远近，来选择适合的PAM 矩阵。如果序列亲缘关系运，也就是说序列间会有很多突变，那就选PAM后面跟一个大数字的矩阵。如果亲缘关系近，也就是突变比较少，序列间大多数地方都是一样的，那就选PAM后面跟-一个小数字的矩阵。

<center>![PAM250矩阵](PAM250矩阵.png)</center>

对角线上的数值为匹配氨基酸的得分，其他位置上≥0的得分代表对应的一对氨基酸为相似氨基酸，<0的是不相似的氨基酸。

### BLOSUM矩阵
BLOSUM矩阵都是通过对大量符合特定要求的序列计算而来的，这点和PAM 矩阵不同。PAM-1矩阵是基于相似度大于85%的序列计算产生的，也就是通过关系较近的序列计算出来的。那些进化距离较运的矩阵，如 PAM-250，是通过PAM-1自乘得到的。也就是说，BLOSUM矩阵的相似性是根据真实数据产生的，而 PAM矩阵是通过矩阵自乘外推而来的。和 PAM 矩阵的另一个不同之处是BLOSUM 矩阵的编号。这些编号，比如 BLOSUM80 中的80，代表这个矩阵是由一致度≥80%的序列计算而来的。同理，BLOSUM62是指这个矩阵是由一致度≥62%的序列计算而来的。因此，BLOSUM后面跟一个小数字的矩阵适合用于比较相似度低的序列，也就是亲缘关系远的序列；而BLOSUM后面跟一个大数字的矩阵适合比较相似度高的序列，也就是亲缘关系近的序列。

<center>![BLOSUM62矩阵](BLOSUM62矩阵.png)</center>

对角线上的数值为匹配氨基酸的得分，≥0的得分代表对应的一对氨基酸为相似氨基酸，<0的是不相似的氨基酸。

<center>![氨基酸差异与矩阵编号对照表](氨基酸差异与矩阵编号对照表.png)</center>

<center>![序列亲缘关系远近与矩阵的选择](序列亲缘关系远近与矩阵的选择.png)</center>

亲缘关系较近的序列之间的比较，用PAM数小的矩阵或BLOSUM数大的矩阵；而亲缘关系较运的序列之间的比较，用PAM数大的矩阵或BLOSUM数小的矩阵。

### 遗传密码矩阵
是通过计算一个氨基酸转换成另一个氨基酸所需的密码子变化的数目而得到的。矩阵的值对应为据此付出的代价。如果变化一个碱基就可以使一个氨基酸的密码子转换为另一个氨基酸的密码子，则这两个氨基酸的替换代价为1；如果需要2个碱基的改变，则替换代价为2；再比如从蛋氨酸(Met）到酪氨酸（Tyr)三个密码子都要变，则代价为3。遗传密码矩阵常用于进化距离的计算，它的优点是计算结果可以直接用于绘制进化树，但是它在蛋白质序列比对，尤其是相似程度很低的蛋白质序列比对中，很少被使用。

<center>![遗传密码子矩阵](遗传密码子矩阵.png)</center>

### 疏水矩阵
是根据氨基酸残基替换前后疏水性的变化而得到的矩阵。若一次氨基酸替换导致疏水特性不发生太大的变化，则这种替换得分高，否则替换得分低。疏水矩阵物理意义明确，有-一定的理化性质依据，适用于偏重蛋白质功能方面的序列比对。在这个矩阵里，氨基酸按照亲疏水性排列。前边是亲水的，后面是疏水的。

<center>![疏水矩阵](疏水矩阵.png)</center>

# 双序列比较
比较两个序列的方法有打点法和序列比对法。

## 打点法
打点法是最简单的比较两个序列的方法，理论上可以用纸和笔来完成。如果要比较下面这两条序列：

<center>![](seq1.png)</center>

我们需要把序列1整齐的水平书写，然后把序列2整齐的竖直书写，然后依次横横竖竖的比较每一个位置上的残基。相同的话就在这个位置上打个点，不同话，什么也不干。这样我们一共需要比较序列1的长度乘以序列2的长度个位置，也就是10乘9个位置，也就是进行90次比较，最终产生图1的打点矩阵。

<center>![序列1和序列2的打点图](序列1和序列2的打点图.png)</center>

在打点矩阵中，连续的对角线及对角线的平行线代表两条序列中相同的区域。这个矩阵中在主对角线位置上连续的红色的对角线说明这个位置对应的序列1的部分和序列2的部分是完全相同的，都是THEFA。此外，跟红对角线平行的蓝色平行线和绿色平行线，同样指出了序列1和序列2中两条相同的序列。也就是序列1和序列2中对应位置的TCAT，以及序列1和序列2中对应位置的AT。由这三条线，我们找到了序列1和序列2中三条相同的子序列。最后，我们放眼全局，红色的线和蓝色的线加起来基本上构成了一条主对角线。由此我们可以得出结论：序列1和序列2是比较相似的两条序列。事实上，如果直接看一下这两条序列，确实是挺相似的。如果是风马牛不相及的两条序列，做出的打点矩阵里是不会出现对角线的，哪怕是模糊的对角线，也不会出现。比如，让序列1和序列3打点做出的打点图中，完全是散点，根本就没有连续的线，更别提主对角线了。

<center>![序列1和序列3的打点图](序列1和序列3的打点图.png)</center>

除了可以用打点法给两条不同的序列打点，还可以用-一条序列自己跟自己打点。这样可以发现序列中重复的片段。比如我们让下面这条序列自己和自己打点：

<center>![](seq2.png)</center>

这样的打点矩阵必然是对称的，并且一定有一条主对角线。此外，在横向或纵向上，与主对角线平行的短平行线所对应的序列片段就是重复的部分。其中，红色短平行线对应的THE在序列中重复出现了3次。包括主对角线在内，平行线出现的次数就是重复的次数。

<center>![序列自己和自己打点寻找重复序列](序列自己和自己打点寻找重复序列.png)</center>

用这种方法我们还可以快捷的发现序列中的串联重复序列以及重复的次数。我们只要数数在半个矩阵中包括主对角线在内的所有等距的平行线的个效，就可以知道重复的次数，而且最短的平行线对应的序列就是重复单元。短的串联复序列具有高度多态性，也就是说不同的个体间重复次数存在差异,而且这种差异在基因遗传过程中一般遵循孟德尔共显性遗传规律,所以快速查找某些特定的短的串联复序列的重复次数可以用于法医学的个体识别或亲子鉴定等领域。

<center>![打点法寻找串联重复序列](打点法寻找串联重复序列.png)</center>

## 序列比对法

### 全局比对
经典的全局比对算法是Needleman-Wunsch 算法。1970 年，Needleman 和Wunsch首先将动态规划法应用于两条序列的全局比对，后来这个算法就称为Needleman-Wunsch 算法。今天，所有比对软件使用的算法都是从这个经典算法衍生出来的。
我们用Needleman-Wunsch 算法为序列p和序列q创建全局比对。输入值除了两条序列之外，还要有替换积分矩阵以确定不同字母间的相似度得分，以及空位罚分。空位罚分就是当字母对空位的时候应该得几分。我们还是希望一致或相似的字母尽可能的对在一起，字母对空位的情况和不相似的字母对在一起的情况一样，都不是我们希望的，还是少出现为好，所以通常字母对空位会得到一个负分，这个负分就叫做空位罚分。这里我们让空位罚分，也就是gap分值为-5分。在比对中没有空位对空位的情况。输入值就是这些。
<center>![](seq3.png)</center>
接下来我们要创建一个得分矩阵，并根据公式把得分矩阵填满。填满后全局比对就会跃然于纸上。得分矩阵的第-一-行是序列p，第一列是序列q，这一步和打点法很像。不过要注意，p和q的前面各留一个空列和一个空行，也就是第0列和第0行。
<center>![](seq4.png)</center>

现在开始给得分矩阵赋值。根据公式：
s(0,0)是初始值0。
第0行: s(0，j) = gap * j
j从1到m, m是序列p的长度。也就是s(0,1)=gap*1=-5，s(0,2)=gap*2=-10，依次类推。第0行实际是一种极端情况的假设。也就是当序列p全部对空位时的得分。A对空位是-5分，AC都对空位就累计到了-10分，ACG都对空位就累积到了-15分，如果序列p全部对空位，最终的累积得分就是-25分。
第0列: s(i,0) = gap * i
第0列和第0行一样，也是反映了序列q如果全部对空位的累计得分。对一个空位累积gap*1=-5分，对两个空位累积gap*2=-10分，对三个空位累积gap* 3=-15分，对四个空位累积gap*4=-20分。
<center>![](seq5.png)</center>

第0行和第0列相对简单，其他的格就稍微复杂一点儿了。接下来填s(1,1)。这个格里的值来源于三个值中的最大值。哪那三个值呢，一个是上面格s(0,1)里的值加gap，一个是左面格s(1,0)里的值加gap，还有一个是斜上格s(0,0)里的值加当前这个位置字母对字母在替换记分矩阵里的分值w(i,j)。就是累积到这个位置时，是字母对字母得分高，还是序列p的字母对空位得分高，还是序列q的字母对空位得分高？有且只有这三种情况，我们要的是得分最高的那种情况。逐个看一下，上面格 s(0,1)+gap=-5+-5=-10。左面格s(1,0) +gap=-5+-5=-10。斜上格s(0,0)+w(1,1)=0+10=10。max(-10,-10,10)=10。所以当前这个格s(1,1)的分值就是10。此外，我们还需要用箭头记录一下这个10是从哪里来的。它是从斜上这个格来的，所以我们画一个指向斜上的箭头。

<center>![](seq6.png)</center>
接下这个格s(1,2)值的计算，仍然是找三个值中的最大值。上面格s(0,2)+gap=-10+-5=-15。左面格s (1,1)+gap=10+-5=5。斜上格s(0,1)+w(1,2)=-5+-3=-8。max(-15,5,-8)=5。大值是5，来源于左面格s(1,1)，画上向左的箭头。
<center>![](seq7.png)</center>

按照上面的公式，将整个得分矩阵填满。这时，我们再回过头来看一下第一行和第一列。其实，第一行的每一个值都是从左边的格加gap来的。所以我们给它们补上向左的箭头。第一列的每一个值都是从上边的格加gap来的。所以我们给它们补上向上的箭头。至此，所有的箭头和数值就都填好了。填满之后，右下角的分数就是整个全局比对最终的得分。然后从这个位置开始追溯箭头一直到左上角的零，并且把这些箭头标记出来。
<center>![](seq8.png)</center>

图中标出的红色箭头是写出全局比对的唯一依据。追溯箭头是从右下角到左上角，但是写全局比对是从左上角开始，如果是斜箭头则是字符对字符，如果是水平箭头或垂直箭头则是字符对空位，箭头指着的序列为空位。我们看第一个是斜箭头，字母对字母，就是A对A，第二个是水平箭头，字母对空位，箭头指着的序列是空位，也就是C对空位。然后斜箭头G对A，斜箭头T对T，斜箭头C对C，一直写到右下角，全局比对就出现了。唯一的一个空位插在序列q的A与A之间，这样最终的比对得分最高。不信的话可以试试，其他任何一种插入空位的比对结果，得分都不会超过21分。因为我们在得分矩阵的创建过程中，每一步都是在上一步最优的情况下得出的当前最优结果。
<center>![](seq9.png)</center>

### 局部比对
局部比对的算法和全局比对很相似，只是在选最大值时通过增加了第四个元素“0”，来达到比对局部的效果。序列p和序列q，一长一短，其他输入值跟全局比对的一样。
<center>![](seq10.png)</center>

局部比对的计算公式在全局比对的基础上增加了第四个元素“0”。得分矩阵初始值仍是0，但第一行和第一列与全局比对不同，全是0。
<center>![](seq11.png)</center>

从s(1,1)开始要选择四个值中的最大值。除了上面格s(0,1)+gap=0+-5=-5，左边格s(1,0)+gap=0+-5=-5，斜上格s(0,0)+w(1,1)=0+-3=-3，还有一个0。max (-5,-5,-3,0)=0。并且这个0既不是从上面格，也不是从左边格，以及斜上格三个方向来的，而是来自于公式里增加的“0”，所以不用画箭头。

<center>![](seq12.png)</center>
s(1,4)的计算：上面格 s(0,4) +gap=0+-5=-5，左边格s(1,3)+gap=4+-5=-1，斜上格s(0,3)+w(1,4)=0+0=0，还有一个0。max (-5,-1,0,0 )=0。这个0和s(1,1)的0是不一样的。这个0应该画上斜上的箭头，因为它可以来自公式中的0，也可以来自斜上格。而s(1,1)的0没有箭头因为它只来自公式中的0。两种情况虽然都是0，但来源不同，一定要通过箭头标识清楚。
<center>![](seq13.png)</center>

按照公式，填充满整个得分矩阵。与全局比对不同，局部比对的得分不是在右下角，而是在整个矩阵中找最大值。这个最大值才是局部比对的最终得分，他可能出现在任何一个位置。这次箭头追溯也不是从右下角到左上角，而是从刚刚找到的最大值开始追溯到没有箭头为止。追溯箭头终止的位置也可以是得分矩阵中的任何一个位置。
<center>![](seq14.png)</center>

最后根据标记好的箭头写出比对结果。从左上到右下标记的红色箭头依次是：斜箭头字母对字母，C对C：斜箭头字母对字母，G对G。相比这两条序列的全局比对结果，两端的空位在局部比对中就全部被忽略掉了。
<center>![](seq15.png)</center>

## 在线双序列比对工具
|软件名|比对类型|网址链接|
| :---: | :---: | :---: |
|EMBL|Global/Local|http://www.ebi.ac.uk/Tools/psa|
|PIR|Global|http://pir.georgetown.edu/pirwww/search/pairwise.shtml|
|Lalign|Global/Local|http://www.ch.embnet.org/software/LALIGN form.html|
|LAGAN|Global|http://lagan.stanford.edu/lagan_web/index.shtml|
|AlignMe|Alignment of Membrane Proteins|http://www.bioinfo.mpg.de/AlignMe/AlignMe.html|
|MCALIGN|Alignment of non-coding DNA sequences|http://homepages.ed.ac.uk/eang33/mcalign/mcinstructions.html|
|Biotools|Global/Local|http://1.51.215.28/~gong.i/biotools|

## BLAST搜索
BLAST是Basic Local Alignment Search Tool的首字母缩写，直译过来就是基本局部比对搜索工具。BLAST的基本原理要点是片段对的概念。所谓片段对是指两个给定序列中的一对子序列，它们的长度相等，且可以形成无空位的完全匹配。图中方框里的就是两个片段对。BLAST从头至尾将两条序列扫描一遍并找出所有片段对，并在允许的阈值范围内对片段对进行延伸，最终找出高分值片段对(high-scoring pairs,HSPs)。这样的计算复杂度是n的一次方(n是序列的长度)。如果做双序列比对话需要构建一个n乘以n的表格，计算复杂度是n的二次方。所以找高分值片段对比做双序列比对节省了大量的时间，当然，前提是牺牲了一定的准确度。
<center>![](seq16.png)</center>

BLAST实际上是综合在一起的一组工具的统称，它不仅可用于直接对蛋白质序列数据库和核酸序列数据库进行搜索，而且可以将待搜索的核酸序列翻译成蛋白质序列后再进行搜索，或者反之，以提高搜索效率。因此BLAST可以分为：

1. **BLASTp**

用于蛋白质序列搜索蛋白质序列数据库

2. **BLASTn**

用于核酸序列搜索核酸序列数据库

3. **BLASTx**

是将核酸序列按6条链翻译成蛋白质序列后搜索蛋白质序列数据库。

4. **tBLASTn**

是用蛋白质序列搜核酸序列数据库，核酸数据库中的核酸序列要按6条链翻译成蛋白质序列后再搜索。

5. **tBLASTx**

是将核酸序列按6条链翻译成蛋白质序列后搜索核酸序列数据库，核酸数据库中的所有核酸序列也要按6条链翻译成的蛋白质序列后再被搜索。

<center>![](seq17.png)</center>

# 多序列比对

